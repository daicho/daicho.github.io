<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DERBY RACE CARD</title>
    <style>
/* リセット & 基本設定 */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', 'Yu Gothic', 'Meiryo', sans-serif;
    background: linear-gradient(135deg, #f5f7fa 0%, #e8ecf1 100%);
    color: #2c3e50;
    min-height: 100vh;
    overflow-x: hidden;
}

/* 画面切り替え */
.screen {
    display: none;
    min-height: 100vh;
    padding: 20px;
    animation: fadeIn 0.5s ease-in;
}

.screen.active {
    display: block;
}

@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* コンテナ */
.container {
    max-width: 600px;
    margin: 0 auto;
    padding: 30px 20px;
}

/* タイトル */
.title {
    font-size: 3rem;
    text-align: center;
    margin-bottom: 30px;
    color: #c9a42b;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
    letter-spacing: 8px;
    font-weight: 600;
}

.screen-title {
    font-size: 2rem;
    text-align: center;
    margin-bottom: 30px;
    color: #c9a42b;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
    letter-spacing: 4px;
}

/* 入力グループ */
.input-row {
    display: flex;
    gap: 20px;
    margin-bottom: 30px;
}

.input-row .input-group {
    flex: 1;
    margin-bottom: 0;
}

.input-group {
    margin-bottom: 25px;
}

.input-group label {
    display: block;
    margin-bottom: 8px;
    color: #495057;
    font-size: 0.95rem;
    font-weight: 600;
}

.input-group input,
.input-group select {
    width: 100%;
    padding: 12px 15px;
    background: #ffffff;
    border: 2px solid rgba(201, 164, 43, 0.3);
    border-radius: 8px;
    color: #2c3e50;
    font-size: 1rem;
    transition: all 0.3s ease;
    cursor: pointer;
}

.input-group input:focus,
.input-group select:focus {
    outline: none;
    border-color: #c9a42b;
    background: #fffef8;
    box-shadow: 0 0 10px rgba(201, 164, 43, 0.2);
}

/* 参加者名入力テーブル */
.participant-table-wrapper {
    margin-bottom: 30px;
    overflow-x: auto;
}

.participant-table {
    width: 100%;
    border-collapse: collapse;
    background: #ffffff;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

.participant-table thead {
    background: rgba(212, 175, 55, 0.15);
}

.participant-table th {
    padding: 15px 20px;
    text-align: center;
    color: #6c5d2e;
    font-weight: 600;
    font-size: 0.95rem;
    letter-spacing: 1px;
    border-bottom: 2px solid rgba(201, 164, 43, 0.2);
}

.participant-table tbody tr {
    border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    transition: background-color 0.2s ease;
}

.participant-table tbody tr:hover {
    background: rgba(212, 175, 55, 0.05);
}

.participant-table tbody tr:last-child {
    border-bottom: none;
}

.participant-table td {
    padding: 12px 20px;
}

.participant-table .number-cell {
    text-align: center;
    font-weight: 600;
    color: #c9a42b;
    font-size: 1rem;
    width: 80px;
}

.participant-table input {
    width: 100%;
    padding: 10px 12px;
    background: #ffffff;
    border: 1px solid rgba(201, 164, 43, 0.3);
    border-radius: 6px;
    color: #2c3e50;
    font-size: 0.95rem;
    transition: all 0.3s ease;
}

.participant-table input:focus {
    outline: none;
    border-color: #c9a42b;
    background: #fffef8;
}

.participant-table input.duplicate-error {
    border-color: #dc3545;
    background: #fff5f5;
}

.participant-table input.duplicate-error:focus {
    border-color: #dc3545;
    background: #fff5f5;
    box-shadow: 0 0 10px rgba(220, 53, 69, 0.2);
}

/* ボタン */
.btn {
    width: 100%;
    padding: 15px 30px;
    font-size: 1.1rem;
    font-weight: 600;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
    letter-spacing: 2px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
}

.btn-primary {
    background: linear-gradient(135deg, #d4af37 0%, #c9a42b 100%);
    color: #ffffff;
}

.btn-primary:hover:not(:disabled) {
    background: linear-gradient(135deg, #e5c158 0%, #d4af37 100%);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
}

.btn-primary:disabled {
    background: #d0d0d0;
    color: #8a8a8a;
    cursor: not-allowed;
    opacity: 0.6;
}

.btn-secondary {
    background: #ffffff;
    color: #2c3e50;
    border: 2px solid rgba(201, 164, 43, 0.5);
    margin-top: 20px;
}

.btn-secondary:hover {
    background: #fffef8;
    border-color: #c9a42b;
    transform: translateY(-2px);
}

/* 選択テーブル */
.selection-table-wrapper {
    margin-bottom: 30px;
    overflow-x: auto;
}

.selection-table {
    width: 100%;
    border-collapse: collapse;
    background: #ffffff;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

.selection-table thead {
    background: rgba(212, 175, 55, 0.15);
}

.selection-table th {
    padding: 15px;
    text-align: center;
    color: #c9a42b;
    font-weight: 600;
    font-size: 1rem;
    letter-spacing: 1px;
}

.selection-table td {
    padding: 12px;
    text-align: center;
    border-top: 1px solid rgba(0, 0, 0, 0.05);
}

.selection-table .frame-number {
    font-size: 1.3rem;
    font-weight: 700;
    color: #c9a42b;
}

.selection-table select {
    width: 100%;
    padding: 10px;
    background: #ffffff;
    border: 1px solid rgba(201, 164, 43, 0.4);
    border-radius: 6px;
    color: #2c3e50;
    font-size: 0.95rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.selection-table select:focus {
    outline: none;
    border-color: #c9a42b;
    background: #fffef8;
}

/* スクラッチカード */
.scratch-container {
    display: flex;
    gap: 20px;
    margin-bottom: 30px;
    flex-wrap: nowrap;
}

.scratch-section {
    flex: 1;
    min-width: 0;
}

.scratch-section h3 {
    text-align: center;
    margin-bottom: 15px;
    color: #495057;
    font-size: 1.3rem;
    font-weight: 600;
    letter-spacing: 2px;
}

.scratch-card {
    position: relative;
    background: #ffffff;
    border: 2px solid rgba(201, 164, 43, 0.4);
    border-radius: 10px;
    overflow: hidden;
    min-height: 300px;
    cursor: pointer;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

.scratch-card canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 2;
}

.scratch-content {
    position: relative;
    z-index: 1;
    padding: 30px 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 300px;
}

.scratch-content .winner-item,
.scratch-content .payout-item {
    background: rgba(212, 175, 55, 0.12);
    padding: 15px 25px;
    margin: 8px 0;
    border-radius: 8px;
    font-size: 1.8rem;
    font-weight: 700;
    color: #c9a42b;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
    min-width: 120px;
    text-align: center;
}

/* 枠選択情報 */
.frame-selection-info {
    margin-bottom: 30px;
    background: #ffffff;
    border: 2px solid rgba(201, 164, 43, 0.3);
    border-radius: 10px;
    padding: 25px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

.frame-selection-info h3 {
    text-align: center;
    margin-bottom: 20px;
    color: #495057;
    font-size: 1.3rem;
    font-weight: 600;
    letter-spacing: 2px;
}

.frame-selection-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 12px;
}

.frame-selection-item {
    display: flex;
    align-items: center;
    gap: 8px;
    background: rgba(212, 175, 55, 0.08);
    padding: 10px 15px;
    border-radius: 8px;
    transition: all 0.2s ease;
}

.frame-selection-item:hover {
    background: rgba(212, 175, 55, 0.15);
    transform: translateY(-1px);
}

.frame-selection-number {
    font-size: 1.5rem;
    font-weight: 700;
    color: #c9a42b;
    min-width: 30px;
    text-align: center;
}

.frame-selection-name {
    font-size: 0.95rem;
    color: #2c3e50;
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* レスポンシブ対応 */
@media (max-width: 768px) {
    .title {
        font-size: 2.5rem;
        letter-spacing: 6px;
    }

    .container {
        padding: 20px 15px;
    }

    .frame-selection-list {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    }
}

@media (max-width: 480px) {
    .title {
        font-size: 2rem;
        letter-spacing: 4px;
    }

    .screen-title {
        font-size: 1.5rem;
        letter-spacing: 2px;
    }

    .scratch-content .winner-item,
    .scratch-content .payout-item {
        font-size: 1.2rem;
        padding: 12px 20px;
    }
}
    </style>
</head>
<body>
    <!-- タイトル画面 (参加者設定) -->
    <div id="titleScreen" class="screen active">
        <div class="container">
            <h1 class="title">DERBY RACE CARD</h1>

            <div class="input-row">
                <div class="input-group">
                    <label for="numParticipants">参加者数</label>
                    <select id="numParticipants">
                        <!-- 1～100の選択肢が動的に生成される -->
                    </select>
                </div>

                <div class="input-group">
                    <label for="numWinners">勝者枠数</label>
                    <select id="numWinners">
                        <!-- 1～参加者数の選択肢が動的に生成される -->
                    </select>
                </div>
            </div>

            <div class="participant-table-wrapper">
                <table id="participantTable" class="participant-table">
                    <thead>
                        <tr>
                            <th>番号</th>
                            <th>名前</th>
                        </tr>
                    </thead>
                    <tbody id="participantNames">
                        <!-- 参加者名入力欄が動的に生成される -->
                    </tbody>
                </table>
            </div>

            <button id="startGameBtn" class="btn btn-primary" disabled>ゲーム開始</button>
        </div>
    </div>

    <!-- 枠選択画面 -->
    <div id="selectionScreen" class="screen">
        <div class="container">
            <h2 class="screen-title">枠選択</h2>

            <div class="selection-table-wrapper">
                <table id="selectionTable" class="selection-table">
                    <thead>
                        <tr>
                            <th>番号</th>
                            <th>名前</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- 枠選択行が動的に生成される -->
                    </tbody>
                </table>
            </div>

            <button id="startRaceBtn" class="btn btn-primary" disabled>レース開始</button>
        </div>
    </div>

    <!-- 結果表示画面 (スクラッチカード) -->
    <div id="resultScreen" class="screen">
        <div class="container">
            <h2 class="screen-title">WINNERS & ODDS</h2>

            <div class="scratch-container">
                <div class="scratch-section">
                    <h3>勝　者</h3>
                    <div class="scratch-card" id="scratchWinners">
                        <canvas id="canvasWinners"></canvas>
                        <div class="scratch-content" id="winnersContent">
                            <!-- 勝者枠番号が表示される -->
                        </div>
                    </div>
                </div>

                <div class="scratch-section">
                    <h3>配　当</h3>
                    <div class="scratch-card" id="scratchPayouts">
                        <canvas id="canvasPayouts"></canvas>
                        <div class="scratch-content" id="payoutsContent">
                            <!-- 配当比率が表示される -->
                        </div>
                    </div>
                </div>
            </div>

            <div class="frame-selection-info">
                <h3>選択枠</h3>
                <div id="frameSelectionList" class="frame-selection-list">
                    <!-- 枠選択情報が表示される -->
                </div>
            </div>

            <button id="backToTitleBtn" class="btn btn-secondary">タイトルに戻る</button>
        </div>
    </div>

    <script>
// ゲーム状態管理
const GameState = {
    numParticipants: 8,
    numWinners: 3,
    participants: [], // 現在表示されている参加者名
    allParticipants: {}, // すべての入力内容を保持 { index: name }
    frameSelections: {}, // { frameNumber: participantName }
    winners: [], // 勝者枠番号の配列
    payouts: {} // { frameNumber: payoutRatio }
};

// 画面切り替え
function showScreen(screenId) {
    document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('active');
    });
    document.getElementById(screenId).classList.add('active');
}

// タイトル画面の初期化
function initTitleScreen() {
    // 参加者数の選択肢を生成（1～100）
    const numParticipantsSelect = document.getElementById('numParticipants');
    numParticipantsSelect.innerHTML = '';
    for (let i = 1; i <= 100; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = i;
        numParticipantsSelect.appendChild(option);
    }

    // LocalStorageから復元
    try {
        const savedData = localStorage.getItem('gameData');
        if (savedData) {
            const data = JSON.parse(savedData);
            GameState.numParticipants = data.numParticipants;
            GameState.numWinners = data.numWinners;
            GameState.participants = data.participants || [];
            
            // 保存された参加者をallParticipantsに復元
            GameState.allParticipants = {};
            GameState.participants.forEach((name, index) => {
                if (name) {
                    GameState.allParticipants[index] = name;
                }
            });

            numParticipantsSelect.value = GameState.numParticipants;
        } else {
            numParticipantsSelect.value = 8; // デフォルト値
        }
    } catch (e) {
        console.error('LocalStorage読み込みエラー:', e);
        numParticipantsSelect.value = 8; // デフォルト値
    }

    // 勝者枠数の選択肢を更新
    updateWinnersSelect();
    updateParticipantInputs();

    // イベントリスナー
    document.getElementById('numParticipants').addEventListener('change', (e) => {
        // 入力欄から現在の値を取得してGameStateに保存
        saveCurrentParticipantInputs();
        
        GameState.numParticipants = parseInt(e.target.value);
        updateWinnersSelect();
        updateParticipantInputs();
    });

    document.getElementById('numWinners').addEventListener('change', (e) => {
        GameState.numWinners = parseInt(e.target.value);
    });

    document.getElementById('startGameBtn').addEventListener('click', () => {
        // 最新の入力内容を保存
        saveCurrentParticipantInputs();
        
        // LocalStorageに保存
        try {
            const data = {
                numParticipants: GameState.numParticipants,
                numWinners: GameState.numWinners,
                participants: GameState.participants
            };
            localStorage.setItem('gameData', JSON.stringify(data));
        } catch (e) {
            console.error('LocalStorage保存エラー:', e);
        }

        GameState.frameSelections = {};
        initSelectionScreen();
        showScreen('selectionScreen');
    });
}

// 勝者枠数の選択肢を更新
function updateWinnersSelect() {
    const numWinnersSelect = document.getElementById('numWinners');
    numWinnersSelect.innerHTML = '';
    
    for (let i = 1; i <= GameState.numParticipants; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = i;
        numWinnersSelect.appendChild(option);
    }
    
    // 現在の勝者枠数が新しい参加者数を超える場合は調整
    if (GameState.numWinners > GameState.numParticipants) {
        GameState.numWinners = GameState.numParticipants;
    }
    
    numWinnersSelect.value = GameState.numWinners;
}

// 現在の入力欄の値をGameStateに保存
function saveCurrentParticipantInputs() {
    const inputs = document.querySelectorAll('#participantNames input');
    inputs.forEach((input, index) => {
        const value = input.value.trim();
        if (value) {
            GameState.allParticipants[index] = value;
        } else {
            delete GameState.allParticipants[index];
        }
        GameState.participants[index] = value;
    });
}

// 参加者名入力欄の更新
function updateParticipantInputs() {
    const tbody = document.getElementById('participantNames');
    
    // 入力欄の数が変わる場合のみ再生成
    const currentInputCount = tbody.querySelectorAll('tr').length;
    if (currentInputCount === GameState.numParticipants) {
        // 入力欄の数が同じ場合は何もしない（入力内容を保持）
        return;
    }
    
    tbody.innerHTML = '';
    GameState.participants = [];

    for (let i = 0; i < GameState.numParticipants; i++) {
        const tr = document.createElement('tr');

        const tdNumber = document.createElement('td');
        tdNumber.textContent = i + 1;
        tdNumber.className = 'number-cell';

        const tdName = document.createElement('td');
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = `参加者${i + 1}の名前`;
        // allParticipantsから入力内容を復元
        input.value = GameState.allParticipants[i] || '';
        input.dataset.index = i;

        input.addEventListener('input', (e) => {
            const index = parseInt(e.target.dataset.index);
            const value = e.target.value.trim();
            GameState.participants[index] = value;
            
            // allParticipantsにも保存
            if (value) {
                GameState.allParticipants[index] = value;
            } else {
                delete GameState.allParticipants[index];
            }
            
            checkDuplicateNames();
            checkAllParticipantsEntered();
        });

        tdName.appendChild(input);
        tr.appendChild(tdNumber);
        tr.appendChild(tdName);
        tbody.appendChild(tr);

        GameState.participants[i] = GameState.allParticipants[i] || '';
    }

    checkDuplicateNames();
    checkAllParticipantsEntered();
}

// 参加者名の重複をチェック
function checkDuplicateNames() {
    const inputs = document.querySelectorAll('#participantNames input');
    const nameCount = {};
    const duplicateNames = new Set();
    
    // 入力された名前をカウント（空文字列は除外）
    inputs.forEach(input => {
        const name = input.value.trim();
        if (name) {
            nameCount[name] = (nameCount[name] || 0) + 1;
            if (nameCount[name] > 1) {
                duplicateNames.add(name);
            }
        }
    });
    
    // 重複している入力欄にエラースタイルを適用
    inputs.forEach(input => {
        const name = input.value.trim();
        if (name && duplicateNames.has(name)) {
            input.classList.add('duplicate-error');
        } else {
            input.classList.remove('duplicate-error');
        }
    });
    
    return duplicateNames.size === 0;
}

// 全参加者名が入力されているかチェック
function checkAllParticipantsEntered() {
    const allEntered = GameState.participants.every(name => name.length > 0);
    const noDuplicates = checkDuplicateNames();
    document.getElementById('startGameBtn').disabled = !(allEntered && noDuplicates);
}

// 枠選択画面の初期化
function initSelectionScreen() {
    const tbody = document.querySelector('#selectionTable tbody');
    tbody.innerHTML = '';

    for (let i = 1; i <= GameState.numParticipants; i++) {
        const tr = document.createElement('tr');

        const tdFrame = document.createElement('td');
        tdFrame.className = 'frame-number';
        tdFrame.textContent = i;

        const tdSelect = document.createElement('td');
        const select = document.createElement('select');
        select.dataset.frame = i;

        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = '選択してください';
        select.appendChild(defaultOption);

        GameState.participants.forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            select.appendChild(option);
        });

        select.addEventListener('change', (e) => {
            const frame = parseInt(e.target.dataset.frame);
            const selectedName = e.target.value;

            if (selectedName) {
                GameState.frameSelections[frame] = selectedName;
            } else {
                delete GameState.frameSelections[frame];
            }

            updateSelectionOptions();
            checkAllFramesSelected();
        });

        tdSelect.appendChild(select);
        tr.appendChild(tdFrame);
        tr.appendChild(tdSelect);
        tbody.appendChild(tr);
    }

    checkAllFramesSelected();

    document.getElementById('startRaceBtn').addEventListener('click', () => {
        determineRaceResults();
        initResultScreen();
        showScreen('resultScreen');
    }, { once: true });
}

// 選択肢の更新 (選択済み参加者を除外)
function updateSelectionOptions() {
    const selectedNames = new Set(Object.values(GameState.frameSelections));
    const selects = document.querySelectorAll('#selectionTable select');

    selects.forEach(select => {
        const currentValue = select.value;
        const frame = parseInt(select.dataset.frame);

        Array.from(select.options).forEach(option => {
            if (option.value === '') return;

            if (selectedNames.has(option.value) && option.value !== currentValue) {
                option.disabled = true;
                option.style.display = 'none';
            } else {
                option.disabled = false;
                option.style.display = '';
            }
        });
    });
}

// 全枠が選択されているかチェック
function checkAllFramesSelected() {
    const allSelected = Object.keys(GameState.frameSelections).length === GameState.numParticipants;
    document.getElementById('startRaceBtn').disabled = !allSelected;
}

// レース結果の決定
function determineRaceResults() {
    // 勝者枠をランダムに選択
    const frames = Array.from({ length: GameState.numParticipants }, (_, i) => i + 1);
    GameState.winners = [];

    for (let i = 0; i < GameState.numWinners; i++) {
        const randomIndex = Math.floor(Math.random() * frames.length);
        GameState.winners.push(frames[randomIndex]);
        frames.splice(randomIndex, 1);
    }

    GameState.winners.sort((a, b) => a - b);

    // 配当比率の決定（合計が1になるように分配）
    // Stars and Bars Methodを使用
    GameState.payouts = {};
    const numParticipants = GameState.numParticipants; // 分母は参加者数
    const numWinners = GameState.numWinners; // 勝者枠数

    // Stars and Bars Method:
    // 0～Nの範囲でM-1個の区切り位置をランダムに選ぶ（重複あり）
    const dividers = [0, numParticipants]; // 両端を追加

    for (let i = 0; i < numWinners - 1; i++) {
        dividers.push(Math.floor(Math.random() * (numParticipants + 1)));
    }

    // ソート
    dividers.sort((a, b) => a - b);

    // 差分を取って配当の分子を求める
    const numerators = [];
    for (let i = 1; i < dividers.length; i++) {
        numerators.push(dividers[i] - dividers[i - 1]);
    }

    // 各勝者枠に配当比率を割り当て
    GameState.winners.forEach((frame, index) => {
        GameState.payouts[frame] = numerators[index] / numParticipants;
    });
}

// 結果画面の初期化
function initResultScreen() {
    // 勝者枠番号の表示
    const winnersContent = document.getElementById('winnersContent');
    winnersContent.innerHTML = '';
    GameState.winners.forEach(frame => {
        const div = document.createElement('div');
        div.className = 'winner-item';
        div.textContent = `${frame}`;
        winnersContent.appendChild(div);
    });

    // 配当比率の表示
    const payoutsContent = document.getElementById('payoutsContent');
    payoutsContent.innerHTML = '';
    GameState.winners.forEach(frame => {
        const div = document.createElement('div');
        div.className = 'payout-item';
        const ratio = GameState.payouts[frame];
        if (ratio === 0) {
            div.textContent = '0';
        } else {
            const numParticipants = GameState.numParticipants;
            const numerator = Math.round(ratio * numParticipants);
            div.textContent = `${numerator}/${numParticipants}`;
        }
        payoutsContent.appendChild(div);
    });

    // 枠選択情報の表示
    const frameSelectionList = document.getElementById('frameSelectionList');
    frameSelectionList.innerHTML = '';
    for (let frame = 1; frame <= GameState.numParticipants; frame++) {
        const participantName = GameState.frameSelections[frame] || '未選択';
        const div = document.createElement('div');
        div.className = 'frame-selection-item';
        
        const frameNumber = document.createElement('span');
        frameNumber.className = 'frame-selection-number';
        frameNumber.textContent = frame;
        
        const participantSpan = document.createElement('span');
        participantSpan.className = 'frame-selection-name';
        participantSpan.textContent = participantName;
        
        div.appendChild(frameNumber);
        div.appendChild(participantSpan);
        frameSelectionList.appendChild(div);
    }

    // スクラッチカードの初期化
    requestAnimationFrame(() => {
        initScratchCard('canvasWinners');
        initScratchCard('canvasPayouts');
    });

    document.getElementById('backToTitleBtn').addEventListener('click', () => {
        showScreen('titleScreen');
    }, { once: true });
}

// スクラッチカードの初期化
function initScratchCard(canvasId) {
    const canvas = document.getElementById(canvasId);
    const ctx = canvas.getContext('2d');

    // キャンバスサイズを親要素に合わせる
    const parent = canvas.parentElement;
    canvas.width = parent.offsetWidth;
    canvas.height = parent.offsetHeight;

    // スクラッチ層の描画（少しざらついた質感を追加）
    ctx.fillStyle = '#2a2a3e';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // ノイズを追加してリアルな質感に
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
        const noise = Math.random() * 15 - 7.5;
        data[i] += noise;     // R
        data[i + 1] += noise; // G
        data[i + 2] += noise; // B
    }
    ctx.putImageData(imageData, 0, 0);

    let isScratching = false;
    let lastX = null;
    let lastY = null;
    const brushSize = 15; // ブラシサイズ

    // 削りカスのパーティクル配列
    const particles = [];
    let particleAnimationId = null;

    // 削る処理（段階的に削れる）
    const scratch = (x, y) => {
        ctx.globalCompositeOperation = 'destination-out';
        // 一度で完全に削れないように透明度を下げる
        ctx.globalAlpha = 0.10; // この値を小さくするほど何度もこする必要がある

        // 前回の位置がある場合は線で繋ぐ
        if (lastX !== null && lastY !== null) {
            const distance = Math.sqrt((x - lastX) ** 2 + (y - lastY) ** 2);
            const steps = Math.max(1, Math.floor(distance / 3)); // 細かく補間

            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const px = lastX + (x - lastX) * t;
                const py = lastY + (y - lastY) * t;

                // ランダムな揺らぎを追加してリアルな削り跡に
                const wobble = Math.random() * 3 - 1.5;
                ctx.beginPath();
                ctx.arc(px + wobble, py + wobble, brushSize + Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();

                // 削りカスのパーティクル生成（削りながら都度発生）
                if (Math.random() < 0.08) {
                    particles.push({
                        x: px,
                        y: py,
                        vx: (Math.random() - 0.5) * 3,
                        vy: Math.random() * 1.5 + 0.5,
                        size: Math.random() * 3 + 1,
                        alpha: 0.8,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.2
                    });
                }
            }
        } else {
            // 初回は単純に円を描画
            ctx.beginPath();
            ctx.arc(x, y, brushSize, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.globalAlpha = 1.0; // 透明度を戻す
        lastX = x;
        lastY = y;

        // パーティクルアニメーションを開始（まだ動いていなければ）
        if (particleAnimationId === null && particles.length > 0) {
            animateParticles();
        }
    };

    // 削りカスのアニメーション（削りながら都度実行）
    const animateParticles = () => {
        const overlay = canvas.parentElement.querySelector('.scratch-particles');
        if (!overlay) {
            particleAnimationId = null;
            return;
        }

        const overlayCtx = overlay.getContext('2d');
        overlayCtx.clearRect(0, 0, overlay.width, overlay.height);

        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];

            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.02; // 重力
            p.vx *= 0.98; // 空気抵抗
            p.alpha -= 0.005;
            p.rotation += p.rotationSpeed;

            if (p.alpha <= 0 || p.y > canvas.height + 10) {
                particles.splice(i, 1);
                continue;
            }

            overlayCtx.save();
            overlayCtx.globalAlpha = p.alpha;
            overlayCtx.fillStyle = '#3a3a4e';
            overlayCtx.translate(p.x, p.y);
            overlayCtx.rotate(p.rotation);
            overlayCtx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
            overlayCtx.restore();
        }

        if (particles.length > 0 || isScratching) {
            particleAnimationId = requestAnimationFrame(animateParticles);
        } else {
            particleAnimationId = null;
        }
    };

    // パーティクル用のキャンバスを追加
    const particleCanvas = document.createElement('canvas');
    particleCanvas.className = 'scratch-particles';
    particleCanvas.width = canvas.width;
    particleCanvas.height = canvas.height;
    particleCanvas.style.position = 'absolute';
    particleCanvas.style.top = '0';
    particleCanvas.style.left = '0';
    particleCanvas.style.width = '100%';
    particleCanvas.style.height = '100%';
    particleCanvas.style.pointerEvents = 'none';
    particleCanvas.style.zIndex = '3';
    canvas.parentElement.appendChild(particleCanvas);

    // マウスイベント
    canvas.addEventListener('mousedown', (e) => {
        isScratching = true;
        const rect = canvas.getBoundingClientRect();
        lastX = e.clientX - rect.left;
        lastY = e.clientY - rect.top;
        scratch(lastX, lastY);
    });

    canvas.addEventListener('mouseup', () => {
        isScratching = false;
        lastX = null;
        lastY = null;
    });

    canvas.addEventListener('mouseleave', () => {
        isScratching = false;
        lastX = null;
        lastY = null;
    });

    canvas.addEventListener('mousemove', (e) => {
        if (isScratching) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            scratch(x, y);
        }
    });

    // タッチイベント
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isScratching = true;
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        lastX = touch.clientX - rect.left;
        lastY = touch.clientY - rect.top;
        scratch(lastX, lastY);
    });

    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        isScratching = false;
        lastX = null;
        lastY = null;
    });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (isScratching) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            scratch(x, y);
        }
    });
}

// 初期化
document.addEventListener('DOMContentLoaded', () => {
    initTitleScreen();
});
    </script>
</body>
</html>
